\subsubsection{Saving Images}
\label{subsubsec:saving_images}
% \todo[inline]{Citations, Why PNG and not BMP or JPG?}

Saved to the specified \texttt{output\_path}.
Resulting in the file names `\texttt{$\{0..(N-1)\}$.png}' (with $N$ beeing the amount of valid frames).

\begin{lstlisting}[style=C++]
  for (int i = throw_bgn_idx; i < (throw_end_idx - 1); ++i) {
    cv::cvtColor(cv_buffer[i % buff_size], cv_transformed, cv::COLOR_BayerBG2BGR);
    cv::imwrite(output_path + std::to_string(i - throw_bgn_idx) + ".png", cv_transformed);
  }
\end{lstlisting}

% https://www.baumer.com/ch/en/service-support/know-how/technical-information-industrial-cameras/baumer-gapi-and-opencv/a/baumer-gapi-and-opencv

% Since RAW formats often have to be converted into other target formats, such as BGR8 or
% BGR12, you can couple an external user buffer to this internal buffer, which then accepts
% the transformed data.

% Using pBuffer->GetMemPtr() accesses the RAW image and pBuffer
% ->GetUserObj() accesses the memory area in the user buffer. In the example, the
% external user buffer is of a size that equates to the target pixel format "BGR8", which
% requires 3 bytes per pixel.
